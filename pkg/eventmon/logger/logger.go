package logger

import (
	"bytes"
	"io"
	"runtime"
	"time"

	"github.com/dusk-network/dusk-blockchain/pkg/core/block"
	"github.com/dusk-network/dusk-blockchain/pkg/core/consensus"
	"github.com/dusk-network/dusk-blockchain/pkg/p2p/wire"
	log "github.com/sirupsen/logrus"
)

// MonitorTopic is the name of the topic on the EventBus
const MonitorTopic = "monitor_topic"

const (
	// ErrWriter is the Error generated by problems with the writer
	ErrWriter byte = iota
	// ErrLog is the Error generated by problems with the Log
	ErrLog
	// ErrOther unexpected errors unrelated to logging or writer
	ErrOther
)

// LogProcessor is a TopicProcessor that intercepts messages on the gossip to create statistics and push the to the monitoring process
// It creates a new instance of logrus and writes on a io.Writer (preferrably UNIX sockets but any kind of connection will do)
type (
	LogProcessor struct {
		*log.Logger
		lastBlock         *block.Block
		p                 wire.EventPublisher
		entry             *log.Entry
		acceptedBlockChan <-chan block.Block
		listener          *wire.TopicListener
	}
)

// New creates a LogProcessor
func New(p wire.EventBroker, w io.WriteCloser, formatter log.Formatter) *LogProcessor {
	logger := log.New()
	logger.Out = w
	if formatter == nil {
		logger.SetFormatter(&log.JSONFormatter{})
	}
	entry := logger.WithFields(log.Fields{
		"process": "monitor",
	})
	acceptedBlockChan, listener := consensus.InitAcceptedBlockUpdate(p)
	return &LogProcessor{
		p:                 p,
		Logger:            logger,
		entry:             entry,
		acceptedBlockChan: acceptedBlockChan,
		listener:          listener,
	}
}

// ListenForNewBlocks in order to send a notification to the node-monitor
func (l *LogProcessor) ListenForNewBlocks() {
	for {
		blk := <-l.acceptedBlockChan
		l.PublishBlockEvent(&blk)
	}
}

// LogNumGoroutine notifies the monitor of the current known number of goroutines
func (l *LogProcessor) LogNumGoroutine() {
	for {
		time.Sleep(5 * time.Second)
		num := runtime.NumGoroutine()
		l.entry.WithFields(log.Fields{
			"code": "goroutine",
			"nr":   num - 1,
		}).Infoln("New goroutine count")
	}
}

// Close the listener and the Writer
func (l *LogProcessor) Close() error {
	l.listener.Quit()
	return l.Out.(io.WriteCloser).Close()
}

// Send specifies the format and the writer for the log
func (l *LogProcessor) Send(entry *log.Entry) error {
	formatted, err := l.Formatter.Format(entry)
	if err != nil {
		return err
	}

	if _, err = l.Out.Write(formatted); err != nil {
		return err
	}

	return nil
}

// ReportError publishes an error on the MonitorTopic
func (l *LogProcessor) ReportError(bErr byte, err error) {
	b := bytes.NewBuffer([]byte{bErr})
	l.p.Publish(MonitorTopic, b)
}

// WithTime decorates the log with time info
func (l *LogProcessor) WithTime(fields log.Fields) *log.Entry {
	entry := l.entry.WithField("time", time.Now())
	if fields == nil {
		return entry
	}
	return entry.WithFields(fields)
}

// WithError decorates the log with an error info
func (l *LogProcessor) WithError(err error) *log.Entry {
	return l.Logger.WithError(err).WithTime(time.Now())
}
